## ARM9嵌入式系统设计与开发应用

### 1 嵌入式系统概述

#### 1.1 嵌入式系统硬件层的组成和功能

组成：嵌入式微处理器、外围电路和外设。外围电路包括电源电路、复位电路、调试接口和存储器电路。

功能：

#### 1.2嵌入式系统中间层的组成和功能

组成：硬件层与软件层之间为中间层（BSP）。

功能：相关硬件初始化、数据的输入/输出操作和硬件设备的配置。

#### 1.3 RTOS的定义和特点

定义：指操作系统能在一个固定时限内对程序调用（或外部事件）做出正确反应，对时序和稳定性要求十分严格。

特点：实时性和稳定性。

#### 1.4 RISC架构的优点

- 固定长度的指令格式，指令规整、简单，2~3种基本寻址方式。
- 使用单周期指令，便于流水线操作执行。
- 大量使用寄存器，数据处理指令只对寄存器进行操作，以提高指令的执行效率。

#### 1.5 哈佛/冯诺依曼结构

哈佛结构：是一种将程序指令存储和数据存储分开的存储器结构。

冯诺依曼结构：是一种将程序指令存储和数据存储合并在一起的存储器结构。

### 2 基于ARM920T核微处理器

#### 2.1 大端/小端存储法

**大端**：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。

**小端**：与大端相反。

#### <font color=blue>2.2 ARM体系架构支持的运行模式</font>

**用户模式**（usr）：ARM处理器正常的程序执行状态。

**快速中断模式**（fiq）：用于高速数据传输或通道处理。

**外部中断模式**（irq）：用于通用的中断处理。

**管理模式**（svc）：操作系统使用的保护模式。

**数据访问终止模式**（abt）：当数据或指令预取终止时进入，用于虚拟存储及存储保护。

**系统模式**（sys）：运行具有特权的操作系统任务。

**未定义指令中止模式**（und）：当未定义指令执行时进入，用于硬件协处理器的软件仿真。

#### <font color=blue>2.3 ARM体系结构支持的异常</font>

| 异常类型     | 优先级    | 地址         | 进入模式 |
| ------------ | --------- | ------------ | -------- |
| 复位         | 1（最高） | 0x0000, 0000 | 管理模式 |
| 未定义指令   | 6         | 0x0000, 0004 | 中止模式 |
| 软件中断     | 7（最低） | 0x0000, 0008 | 管理模式 |
| 预取指令中止 | 5         | 0x0000, 000C | 终止模式 |
| 数据中止     | 2         | 0x0000, 0010 | 终止模式 |
| 保留         |           | 0x0000, 0014 | 保留     |
| IRQ          | 4         | 0x0000, 0018 | IRQ      |
| FIQ          | 3         | 0x0000, 001C | FIQ      |

#### <font color=blue>2.4 对异常的响应</font>

- 将下一条指令的地址存入相应连接寄存器LR。
- 将CPSR复制到相应的SPSR。
- 根据异常类型强制设置CPSR的运行模式位。
- 强制PC从相应异常向量地址取下一条指令执行。

#### <font color=blue>2.5 从异常返回</font>

- 将连接寄存器LR的值减去相应的偏移量后送到PC中。

- 将SPSR复制回CPSR中。

- 若在进入异常处理时设置了中断禁止位，要在此清除。

#### 2.6 程序状态寄存器

包含1个当前程序状态寄存器（CPSR）和5个备份程序状态寄存器（SPSR）。

**条件码标志**：CPSR[31:28]。

N：为1表示运算结果为负数，否则为非负数。

Z：为1表示运算结果为零，否则为非零。

C：为1表示运算结果产生了进位，否则无进位。

V：为1表示符号位溢出，否则无溢出。

**控制位**：CPSR[7:0]。

- 中断禁止位I、F：禁止IRQ、FIQ中断。
- T标志位：反映处理器的运行状态，为1运行于Thumb状态T，否则运行于ARM状态。
- 运行模式位M[4:0]：决定了处理器的运行模式。

| M[4:0] | 十进制 | 处理器模式 |
| ------ | ------ | ---------- |
| 10000  | 0      | 用户模式   |
| 10001  | 1      | FIQ模式    |
| 10010  | 2      | IRQ模式    |
| 10011  | 3      | 管理模式   |
| 10111  | 7      | 中止模式   |
| 11011  | 11     | 未定义模式 |
| 11111  | 15     | 系统模式   |

#### 2.7 汇编指令

**跳转指令**：实现程序流程的跳转。

```assembly
B 目标地址  ;跳转指令中的值时相对当前PC值的一个偏移量
BL 目标地址 ;跳转前，R14保存PC的当前内容
BX 目标地址 ;跳转到指令中指定的目标地址
```

**数据处理指令**：可分为数据传送指令、算术逻辑运算指令和比较指令。

```assembly
MOV 目的寄存器,源操作数  	  ;从寄存器或立即数加载到目的寄存器
MVN 目的寄存器,源操作数  	  ;在传送前先按位取反
CMP 操作数1,操作数2	  		;1 - 2，并更新CPSR的条件标志位
TST 操作数1,操作数2	  		;1 & 2，并更新CPSR的条件标志位
TEQ 操作数1,操作数2	  		;1 | 2，并更新CPSR的条件标志位（1|2）
ADD 目的寄存器,操作数1,操作数2	 ;1 + 2，结果存放在目的寄存器
ADC 目的寄存器,操作数1,操作数2  ;1 + 2，再加上CPSR的C条件标志位，结果放在目的寄存器
SUB 目的寄存器,操作数1,操作数2  ;1 - 2，结果放在目的寄存器
AND 目的寄存器,操作数1,操作数2  ;1 & 2，结果放在目的寄存器
ORR 目的寄存器,操作数1,操作数2  ;1 | 2，结果放在目的寄存器
EOR 目的寄存器,操作数1,操作数2  ;1 ^ 2，结果放在目的寄存器
BIC 目的寄存器,操作数1,操作数2  ;根据操作数2置1的位清除操作数1的某些位，结果放在目的寄存器
```

**乘法/乘加指令**：

```assembly
MUL 目的寄存器,操作数1,操作数2  		;1 * 2，结果放在目的寄存器
MLA 目的寄存器,操作数1,操作数2,操作数3  ;1 * 2 + 3，结果放在目的寄存器，并设置CPSR的条件标志位
```

**程序状态寄存器访问指令**：

```assembly
MRS 通用寄存器,程序状态寄存器    ;将程序状态寄存器的内容传送到目的寄存器
MSR 程序状态寄存器_<域>_,操作数  ;将操作数的内容传送到程序状态寄存器的特定域
; [31:24]: 条件标志位域(f)
; [23:16]: 状态位域(s)
; [15:8]:  扩展位域(x)
; [7:0]:   控制位域(c)
```

**加载/存储指令**：

```assembly
LDR 目的寄存器,<存储器地址>  ;从存储器中将一个32位字数据传送到目的寄存器
STR 源寄存器,<存储器地址>    ;从源寄存器中将一个32位字数据传送到存储器
```

**批量数据加载/存储指令**：

```assembly
LDM(STM){类型} 基址寄存器{!},寄存器列表{^}  ;从基址寄存器指示的一片连续存储器到多个寄存器间传送数据
; 常用类型:
; IA: 每次传送后地址加1
; IB: 每次传送前地址加1
; DA: 每次传送后地址减1
; DB: 每次传送前地址减1
; FD: 满递减堆栈（堆栈向下增长，堆栈指针指向有效数据项的最低地址）
; ED: 空递减堆栈（堆栈向下增长，堆栈指针指向堆栈下的第一个空位置）
; FA: 满递增堆栈
; EA: 空递增堆栈
```

**移位指令**：

```assembly
通用寄存器,LSL(ASL) 操作数  ;将通用寄存器的值逻辑左移操作数指定的位数，低位用0填充
通用寄存器,LSR 操作数  		;将通用寄存器的值逻辑右移操作数指定的位数，左端用0填充
通用寄存器,ASR 操作数		;将通用寄存器的值逻辑左移操作数指定的位数，左端用第31位的值填充
```

**异常产生指令**：

```assembly
SWI 24位的立即数  ;用于产生软件中断，立即数指定用户调用系统例程的类型，相关参数由通用寄存器传递
```

**伪指令**：

```assembly
GBLA 全局变量名  ;用于定义一个全局的数字变量，并初始化为0
MACRO  ;将一段代码定义为一个整体，称为宏指令
$标号 宏名 $参数1,$参数2,...
指令序列
MEND
AREA 段名 属性1,属性2,...  ;用于定义一个代码段或数据段
; 常用属性:
; CODE: 用于定义代码段
; DATA: 用于定义数据段
; READONLY: 只读
; READWRITE: 可读可写
; ALIGN:
; COMMON:
ENTRY  ;用于指定汇编程序的入口
名称 EQU 表达式  ;用于为程序中的常量、标号等定义一个等效字符名称
EXPORT 标号  ;用于声明一个全局的标号，该标号可在其他文件中引用
IMPORT 标号  ;告诉编译器标号在其他源文件中定义
```

#### 2.8 汇编语言和C语言的混合编程

**内嵌汇编**：在C/C++中嵌入汇编语言。

```c
//Linux Gcc支持格式
__asm__("instruction
        ...
        instruction");
//ADS支持格式
__asm{
    instruction
    ...
    instruction
};
```

**调用汇编**：在C/C++中调用汇编程序。

根据ATPCS标准，函数前4个参数通过R0~R3来传递，其它参数通过堆栈(FD)传递。

```c
AREA SCopy,CODE,READONLY
EXPORT strcopy
strcopy                 
	; r0 points to destination string
    ; r1 points to source string
    LDRB r2, [r1],#1    ; load byte and update address
    STRB r2, [r0],#1    ; store byte and update address;
    CMP r2, #0          ; check for zeroterminator
    BNE strcopy         ; keep going if not
    MOV pc,lr           ; Return
    END

int main()
{
    const char *src = "Hello";
    char des[] = "World";
	strcopy(src, des);
    return 0;
}
```

#### 2.9 S3C2410集成的模块功能

- 1个LCD控制器。
- 3个通道的UART。
- 4个通道的DMA。
- 8通道的10位ADC，10位分辨率。
- IIS总线接口。

#### 2.10 内存控制器

**BWSCON**：总线宽度控制寄存器，控制存储器的总线宽度和访问周期。

**BANKCON**~n~：控制寄存器，控制nGCS的时序（片选和访问周期）。

#### 2.11 电源控制模式

正常（Normal）模式：

慢速（Slow）模式：

空闲（Idle）模式：

关断（Power-off）模式：

### 3 基于S3C2410X处理器的嵌入式系统设计

#### <font color=blue>3.1 Nor Flash和Nand Flash的区别</font>

- Nor写入前需先写0，Nand擦除操作简单。
- Nor读速度比Nand稍快一些，Nand写入速度比Nor快很多。
- Nand单元尺寸是Nor的一半，生产更简单，价格低。
- Nor的擦写次数是十万次，Nand是一百万次。

#### 3.2 UART的操作模式与功能

#### 3.3 UART相关寄存器

ULCON：用于选择每帧数据位数、停止位数、奇偶校验模式及是否使用红外模式。

UCON：用于选择时钟、接收和发送中断类型、接收超时使能、接收错误状态中断使能、回环模式、发送接收模式。

UERSTAT：表明是否有帧错误或溢出错误发生。

UTRSTAT：接收/发生状态寄存器。

UTXH：发送缓冲寄存器。

URXH：接收缓冲寄存器。

### 4 基于ARM9和ucos嵌入式系统设计

#### 4.1 ucos内核调度特点

- 只支持基于优先级的抢占式调度算法，不支持时间片轮询。
- 64个优先级，只能创建64个任务（用户只能创建56个）。
- 不支持优先级逆转。
- READY队列通过内存映射表实现快速查询，效率高。
- 支持信号量、消息队列、事件控制块、事件标志组、消息邮箱任务通信机制。
- 支持中断嵌套（嵌套层数可达255层），中断使用当前任务的堆栈保存上下文。

#### 4.2 任务控制块TCB的内容

```c
typedef struct os_tcb{
    OS_STK *OSTCBStkPtr;
    void *OSTCBExtPtr;
    OS_STK *OSTCBStkBottom;
    INT32U OSTCBStkSize;
    INT16U OSTCBOpt;
    INT16U OSTCBId;
    struct os_tcb *OSTCBNext;
    struct os_tcb *OSTCBPrev;
    OS_EVENT *OSTCBEventPtr;
    void *OSTCBMsg;
    INT16U OSTCBDly;
    INT8U OSTCBStat;
    INT8U OSTCBPrio;
    INT8U OSTCBX;
    INT8U OSTCBY;
    INT8U OSTCBBitX;
    INT8U OSTCBBitY;
    BOOLEAN OSTCBDelReq;
}OS_TCB;
```

#### 4.3 就绪表

```c
//使任务进入就绪态
OSRdyGrp |= OSMapTbl[prio>>3];
OSRdyTbl[prio>>3] |= OSMapTbl[prio&0x07];
//查询优先级最高的就绪态任务
y = OSUnMapTbl[OSRdyGrp];
x = OSUnMapTbl[OSRdyTbl[y]];
prio = (y<<3) + x;
```

#### 4.4 ucos的API函数

**任务类**：

```c
/************************************************************************************
* 建立一个新任务
* 参数: task 是指向任务代码的指针。
* pdata 指向一个数据结构，该结构用来在建立任务时向任务传递参数。
* ptos 为指向任务堆栈栈顶的指针。
* prio 为任务的优先级。每个任务必须有一个唯一的优先级作为标识。数字越小，优先级越高。
************************************************************************************/
INT8U OSTaskCreate (void (*task)(void *pd), void *pdata, OS_STK *ptos, INT8U prio);

/************************************************************************************
* 唤醒一个用OSTaskSuspend()函数挂起的任务
* 参数: prio 指定要唤醒任务的优先级。
************************************************************************************/
INT8U OSTaskResume (INT8U prio);

/************************************************************************************
* 无条件挂起一个任务
* 参数: prio 为指定要获取挂起的任务优先级，也可以指定参数OS_PRIO_SELF，挂起任务本身。
************************************************************************************/
INT8U OSTaskSuspend (INT8U prio);
```

**消息类**：

```c
/************************************************************************************
* 建立并初始化一个消息邮箱
* 参数: msg 参数用来初始化建立的消息邮箱。如果该指针不为空，建立的消息邮箱将含有消息。
* 返回: 指向分配给所建立的消息邮箱的事件控制块的指针。如果没有可用的事件控制块，返回空指针。
************************************************************************************/
OS_EVENT *OSMboxCreate (void *msg);

/************************************************************************************
* 任务等待消息，获取邮箱中的消息，若邮箱中没有消息则等待。
* 参数: pevent 是指向即将接受消息的消息邮箱的指针。该指针的值在建立该消息邮箱时可以得到。
* timeout 允许一个任务在经过了指定数目的时钟节拍后还没有得到需要的消息时恢复运行。
* err 是指向包含错误码的变量的指针。
* 返回: 返回接受的消息并将 *err置为OS_NO_ERR。如果没有在指定数目的时钟节拍内接受到需要的消息，
* OSMboxPend()函数返回空指针并且将 *err设置为OS_TIMEOUT。
************************************************************************************/
void *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err);

/************************************************************************************
* 通过消息邮箱向任务发送消息
* 参数: pevent 是指向即将接受消息的消息邮箱的指针。该指针的值在建立该消息邮箱时可以得到。
* msg 是即将实际发送给任务的消息。不允许传递一个空指针。
************************************************************************************/
INT8U OSMboxPost (OS_EVENT *pevent, void *msg);
```

**同步类**：

```c
/************************************************************************************
* 建立一个信号量
* 参数: cnt 建立信号量的初始值，可以为0 ~ 65535的任何值
*************************************************************************************/
OS_EVENT *OSSemCreate (INT16U cnt);

/************************************************************************************
* 等待一个信号量，若信号量不为0，则获取信号量并将信号量减1；若信号量为0则等待。
* 参数: pevent 指向信号量指针。该指针的值在建立该信号量时得到。(参见OSSemCreate ()函数)
* timeout 允许任务在经过指定数目的时钟节拍后还没有得到需要的信号量时；恢复运行状态。
* err 指向包含错误码的变量的指针。返回的错误码可能为以下几种；
* 返回: 无
************************************************************************************/
void OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err);

/************************************************************************************
* 置位指定的信号量，递增该信号量并返回。
* 参数: pevent 指向信号量指针。该指针的值在建立该信号量时得到。
************************************************************************************/
INT8U OSSemPost (OS_EVENT *pevent);
```

#### <font color=blue>4.5 ucos的移植</font>

**移植对处理器的要求**：

- 处理器的C编译器能产生可重入代码。
- 在程序中可以打开或关闭中断。
- 处理器支持中断，且能产生定时中断。
- 处理器支持能够容纳一定量数据的硬件堆栈。
- 处理器有将堆栈指针和其他寄存器存储读出到堆栈（或内存）的指令。

**移植的步骤**：

- 设置os_cpu.h中与处理器和编译器相关的代码。
- 用C语言编写6个操作系统相关的函数。
- 用汇编语言编写4个与处理器相关的函数。
- 编写一个简单的多任务程序来测试移植是否成功。
- 编译并下载移植后的ucos。