## 设备驱动开发

[TOC]

------

### 1 概述

#### 1.1 设备驱动简介

Linux 内核中采用可加载的模块化设计，即将最基本的核心代码编译在内核中，其他的代码可以编译到内核中，或者编译为内核的模块文件（在需要时动态加载）。

常见的驱动程序是作为内核模块动态加载的，比如声卡驱动和网卡驱动等，而Linux最基础的驱动，如CPU、 PCI 总线、TCP/IP 协议、APM（高级电源管理）、VFS 等驱动程序则直接编译在内核文件中。

命令 **lsmod** 列出当前系统中加载的模块，**rmmod** 用于将当前模块卸载。

命令 **insmod** 和 **modprobe** 用于加载当前模块。

#### 1.2 设备分类

Linux 系统的设备分为 3 类：字符设备、块设备和网络设备。

**字符设备**：通常指像普通文件或字节流一样，以字节为单位顺序读写的设备。

**块设备**：通常指一些需要以块为单位随机读写的设备，不仅可以提供随机访问，而且可以容纳文件系统。

**网络设备**：通常是指通过网络能够与其他主机进行数据通信的设备。

#### 1.3 设备号

**设备号**是一个数字，它是设备的标志。设备号的高字节为主设备号，底字节为次设备号。 

**主设备号**表明设备的类型。

**次设备号**通常是用于标明不同的属性，它标志着某个具体的物理设备。

1.4 驱动层次结构

Linux 设备驱动程序包含中断处理程序和设备服务子程序两部 分。

设备服务子程序包含了所有与设备操作相关的处理代码。它从面向用户进程的设备文件系统中接受用户命令，并对设备控制器执行操作。

设备控制器获得系统服务有两种方式：查询和中断。查询方式的工作效率比较低，大多设备以中断方式向设备驱动程序发出输入/输出请求。

1.5 驱动程序与外界的接口

Linux 设备驱动程序与外界的接口可以分为 3 个部分：

- 驱动程序与操作系统内核的接口：通过数据结构 file_operations 完成。
- 驱动程序与系统引导的接口：对设备进行初始化。 
- 驱动程序与设备的接口：驱动程序如何与设备进行交互。

1.6驱动程序的特点

内核代码：设备驱动程序是内核的一部分。

内核接口：设备驱动程序必须为内核或者其子系统提供一个标准接口。

内核机制和服务：设备驱动程序使用一些标准的内核服务。

可装载：大多数的 Linux 操作系统设备驱动程序都可以在需要时装载进内核，在不需要时从内核中卸载。 

可设置：Linux 操作系统设备驱动程序可以集成为内核的一部分，并且在系统编译时可进行相应设置。

动态性：在系统启动且各个设备驱动程序初始化后，驱动程序将维护其控制的设备。

2 字符设备驱动

2.1 编写流程

模块在调用 insmod 命令时被加载，此时的入口点是 init_module()函数，通常在该函 数中完成设备的注册。同样，模块在调用 rmmod 命令时被卸载，此时的入口点是 cleanup_module() 函数，在该函数中完成设备的卸载。

2.2 重要结构

设备驱动程序的入口点，它是一个 在<linux/fs.h>中定义的 struct file_operations 结构，这是一个内核结构，不会出现在用户空间的程序中，

```c
struct file_operations{
    ssize_t (*read)(struct file *filp, char *buff, size_t count, loff_t *offp);
    ssize_t (*write)(struct file *filp, const char *buff, size_t count, loff_t *offp); 
    int (*open) (struct inode *, struct file *);
     int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); 
}
```

2.3 设备驱动程序主要组成

**设备号相关函数**：具备相同主设备号的设备之间共用同一个驱动程序，而用次设备号来标识具体物理设备。

分配设备号有静态和动态的两种方法。静态分配(register_chrdev_region()函数)

**字符设备注册**： Linux 内核中使用 struct cdev 结构来描述字符设备，首先使用 cdev_alloc() 函数向系统申请分配 struct cdev 结构，再用 cdev_init()函数初始化已分配到的结构并与 file_operations 结构关联起来。最后调用 cdev_add()函数将设备号与 struct cdev 结构进行关联并向内核正式报告新设 备的注册。

**打开设备**：函数接口是 open 。

**释放设备**：的函数接口是 release 。注意释放设备和关闭设备是完全不同的。当一个进程释放设备时，其 他进程还能继续使用该设备，只是该进程暂时停止对该设备的使用；而当一个进程关闭设备时，其他进程 必须重新打开此设备才能使用它。

**读写设备**：就是把内核空间的数据复制到用户空间，或者从用户空间复制到内核空间，也就是将内核空间缓冲区里的数据复制到用户空间的缓冲区中或者相反。 

**ioctl**：大部分设备还需要硬件配置和控制等很多其他操作。在字符设备驱动中 ioctl 函数接口给用户提供对设备的非读写操作机制。

**获取内存**：以字节为单位分配内存的函数有 kmalloc，kmalloc 函数返回的是物理地址，申请空间有大小限制。长度是 2 的整次方，并且不会对所获取的内存空间清零。 

**打印信息**：在内核空间要用函数 printk 而不能用平常的函数 printf。printk 还可以定义打印消息的优先级。

3 proc文件系统

/proc 文件系统是一个伪文件系统，它是一种内核和内核模块用来向进程发送信息的机制。这个伪文件系统 让用户可以和内核内部数据结构进行交互，获取有关系统和进程的有用信息，在运行时通过改变内核参数 来改变设置。与其他文件系统不同，/proc 存在于内存之中而不是在硬盘上。

3.1 proc主要目录内容

| 目录名称    | 目录内容           | 目录名称 | 目录内容          |
| ----------- | ------------------ | -------- | ----------------- |
| apm         | 高级电源管理       | ioports  | I/O端口的使用信息 |
| cpuinfo     | CPU相关信息        | kcore    | 内核映像          |
| devices     | 设备信息           | meminfo  | 内存信息          |
| dma         | 使用的DMA通道      | modules  | 加载模块列表      |
| filesystems | 支持的文件系统信息 | mounts   | 加载的文件系统    |
| interrupts  | 中断的使用信息     | version  | 内核版本          |

系统中当前运行的每一个进程都有对应的一 个目录在/proc 下，以进程的 PID 号为目录名，它们是读取进程信息的接口。进程目录结构如下：

| 目录名称 | 目录内容           | 目录名称 | 目录内容                 |
| -------- | ------------------ | -------- | ------------------------ |
| cmdline  | 命令行参数         | cwd      | 当前工作目录链接         |
| environ  | 环境变量值         | exe      | 执行该进程的执行命令文件 |
| fd       | 包含所有文件描述符 | maps     | 内存映像                 |
| mem      | 进程内存使用情况   | statm    | 进程内存状态信息         |
| stat     | 进程状态           | root     | 链接此进程的root目录     |
| status   | 进程当前状态       |          |                          |

4 GPIO驱动程序

4.1 GPIO工作原理

为了控制这些端口，S3C2410 处理器为每个端口组分别提供几种相应的控制寄存器。其中最常用的有端口 配置寄存器（GPACON ~ GPHCON）和端口数据寄存器（GPADAT ~ GPHDAT），配置寄存器设定每个管脚用于何种目的。数据寄存器的每位将对应于某个管脚上的输入或输出。

4.2 GPIO驱动程序

5 块设备驱动

块设备驱动编程接口相对复杂，。块设备驱动程序对整个系统的性能影响较大。系统中使用缓冲区与访问请求的优化管理（合并与重新 排序）来提高系统性能。

5.1 编程流程

块设备驱动程序包括一个 request 请求队列。

5.2 数据结构

每个块设备物理实体由一个 gendisk 结构体来表示，每个 gendisk 中包含了本物理实体的全部信息以及操作函数接口。

```c
struct gendisk{
    int major;
    int first_minor;     /* 主设备号 */ 
    int minors;			 /* 第一个次设备号 */ 
    char disk_name[32];  /* 次设备号个数
    struct hd_struct **part;  /* 分区表 */
}
struct block_device_operations{
    
}
```

5.2 块设备注册和初始化

5.3 块设备请求处理

6 中断编程

中断机制提供了硬件和软件之间异步传递信息的方式。硬件设备在发生某个事件时 通过中断通知软件进行处理。

申请中断的 request_irq 调用，和用于释放中断的 free_irq 调用。

```c
int request_irq(unsigned int irq,
                void (*handler)(int irq, void *dev_id, struct pt_regs *regs),
                unsigned long irqflags, const char *devname, oid *dev_id);
void free_irq(unsigned int irq, void *dev_id);
```

**irq**：要申请的硬件中断号。

**handler**：将要向系统注册的中断处理函数。这是一个回调函数，中断发生时，系统调用这个函数， 传入的参数包括硬件中断号、设备 id 以及寄存器值。

**irqflags**：中断处理的一些属性。

SA_INTERRUPT属性：用于标明中断处理程 序是快速处理程序（置1）还是慢速处理程序（置0）。快速处理程 序被调用时屏蔽所有中断。慢速处理程序只屏蔽正在处理的中断。

 SA_SHIRQ 属性：运行多个设备共享中断，在中断处理程序中根据 dev_id 区分不同设备产生的中断。

**devname**：设备名，会在/dev/interrupts 中显示。 

**dev_id**：在中断共享时会用到。

7 按键驱动程序

