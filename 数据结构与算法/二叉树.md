## 二叉树

[TOC]

------

### 1 树的存储结构

树结构是一种非线性存储结构，存储的是具有**一对多**关系的数据元素的集合。

#### 1.1 树的节点

**结点**：使用树结构存储的每一个数据元素。

**父结点**、**子结点**和**兄弟结点**：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。

**根结点**：每一个非空树都有且只有一个被称为根的结点，即没有父结点的一个结点。

**叶子节点**：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。

#### 1.2 子树和空树

**子树**：树是由根结点和若干棵子树构成的。

**空树**：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。

#### 1.3 结点的度和层次

**结点的度**（Degree）：对于一个结点，拥有的子树数（结点有多少分支）。

**结点的层次**：从一棵树的树根开始，树根所在层为第一层，根的子结点所在的层为第二层，依次类推。

**树的深度**（高度）：树中结点所在的最大的层次。

### 2 二叉树

满足以下两个条件的树就是二叉树：

- 本身是有序树；

- 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

#### 2.1 二叉树的性质

- 二叉树中，第 i 层最多有 2^i-1^ 个结点。

- 如果二叉树的深度为 K，那么此二叉树最多有 2^K^-1 个结点。

- 二叉树中，终端结点数（叶子结点数）为 n~1~，度为 2 的结点数为 n~2~，则 n~1~=n~2~+1。

#### 2.2 满二叉树

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为**满二叉树**。

满二叉树具有以下性质：

- 满二叉树中第 n 层的节点数为2^n-1^个。
- 深度为 k 的满二叉树必有 2^k^-1 个节点 ，叶子数为 2^k-1^。
- 具有 n 个节点的满二叉树的深度为 log~2~(n+1)。

#### 2.3 完全二叉树

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

### 3 二叉树的实现

#### 3.1 顺序表实现

顺序存储只适用于完全二叉树。因此，若想顺序存储普通二叉树，需提前将普通二叉树转化为完全二叉树。完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。

#### 3.2 链表实现

采用链式存储二叉树时，其节点结构由 3 部分构成：

-  指向左孩子节点的指针（Left）；
-  节点存储的数据（data）；
-  指向右孩子节点的指针（Right）；

### 4 二叉查找树

#### 4.1 初始化

二叉查找树的性质：对于树中的每个节点X，它的左子树中所有关键字的值小于X的关键字值，而它右子树中所有关键字值大于X的关键字值。

#### 4.2 查找

**find**：返回指向树中数据为data的节点的指针。当二叉树非空时，首先将待查找的键值与根节点的键值比较，若小于根节点的键值，则继续查找左子树，否则查找右子树。

**findMin**：返回树中数据最小值的节点的指针，从根开始且只要有左子树就向左进行，终点是最小元素。

**findMax**：返回树中数据最大值的节点的指针。

#### 4.3 插入

为将data插入到树中，先进行查找，若找到值为data的节点则什么也不做，否则将data插入到遍历的路径上的最后一点上。

#### 4.4 删除

#### 4.5 遍历

**先序遍历**：访问根节点。访问当前节点的左子树。若当前节点无左子树，则访问当前节点的右子树。

**中序遍历**：访问当前节点的左子树，访问根节点，访问当前节点的右子树。

**后序遍历**：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点。

**层次遍历**：按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。

下图三种遍历的结果为：

![](C:\Users\seasky\Desktop\文件\截图\2-1FS01325394F.png)

```c
//前序遍历
1 2 4 5 3 6 7
//中序遍历
4 2 5 1 6 3 7
//后序遍历
4 5 2 6 7 3 1
//层次遍历
1 2 3 4 5 6 7
```

#### 4.6 实现

```c
typedef struct TreeNode{
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
}TreeNode, *Tree;
/* 初始化 */
Tree initTree(int data){
    Tree t = (Tree)malloc(sizeof(TreeNode));
    if(!t) return NULL;
    t->data = data;
    t->left = t->right = NULL;
    return t;
}
/* 查找值为data的结点 */
TreeNode *find(Tree t){
    if(!T) return NULL;
    if(data < t->data)
        return find(data, t->left);
    else if(data > t->data)
        return find(data, t->right);
    else return t;
}
/* 查找最大值（非递归实现） */
TreeNode *findMax(Tree t){
    if(!t) return NULL;
    while(t->right)
        t = t->right;
    return t;
}
/* 查找最小值（递归实现） */
TreeNode *findMin(Tree t){
    if(t == NULL)
        return NULL;
    if(t->left == NULL)
        return t;
    else
        return findMin(t->left);
}
/* 插入元素 */
Tree insert(int data, Tree t){
    if(!t){
        t = (Tree)malloc(sizeof(TreeNode));
        if(!t) return NULL;
        t->data = data;
        t->left = t->right = NULL;
    }else{
        if(data < t->data)
        	t->left = insert(data, t->left);
    	else if(data > t->data)
            t->right = insert(data, t->right);
        else printf("该结点已存在\n");
    }
    return t;
}
/* 删除元素 */
void delete(int data, Tree t)
{
    
}
/* 先序遍历 */
void preTravel(Tree t){
    if(t != NULL){
        printf("%d", t->data);
        preTravel(t->left);
        preTravel(t->right);
    }
}
/* 中序遍历 */
void inTravel(Tree t){
    if(t != null){
        inTravel(t->left);
        printf("%d", t->data);
        inTravel(t->right);
    }
}
/* 后序遍历 */
void postTravel(Tree t){
    if(t){
        postTravel(t->left);
        postTravel(t->right);
        printf("%d", t->data);
    }
}
```

5 AVL树

AVL树是带有平衡条件的二叉查找树，即其每个结点的左子树和右子树的高度最多差1

5.1 单旋转

5.2 双旋转

6 哈夫曼树

6.1 基础概念

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。

6.2 定义

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为**最优二叉树**，有时也叫**赫夫曼树**或者**哈夫曼树**。

要使树的带权路径长度最小，只需要遵循一个原则，那就是：**权重越大的结点离树根越近**。

