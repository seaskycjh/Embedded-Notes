继承和派生



1 定义

**继承（Inheritance）**可以理解为一个类从另一个类获取成员变量和成员函数的过程。**派生（Derive）**和继承是一个概念，只是站的角度不同。

被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。

2 继承方式

**public继承方式**

- 基类中所有 public 成员在派生类中为 public 属性；
- 基类中所有 protected 成员在派生类中为 protected 属性；
- 基类中所有 private 成员在派生类中不能使用。

protected继承方式

基类中的所有 public 成员在派生类中为 protected 属性；

基类中的所有 protected 成员在派生类中为 protected 属性；

基类中的所有 private 成员在派生类中不能使用。

3) private继承方式

基类中的所有 public 成员在派生类中均为 private 属性；

基类中的所有 protected 成员在派生类中均为 private 属性；

基类中的所有 private 成员在派生类中不能使用。

2.2 改变访问权限

使用 using 关键字可以改变基类成员在派生类中的访问权限，

注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，

3 基类和派生类的构造函数

类的构造函数不能被继承。可以被继承的是基类的普通成员函数。

设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 private 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。

<font color=red>解决方法是：在派生类的构造函数中调用基类的构造函数。</font>

3.1 调用顺序

基类构造函数总是被优先调用，这说明创建派生类对象时，会先调用基类构造函数，再调用派生类构造函数。构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。

<font color=red>注意：派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</font>

3.2 调用规则

通过派生类创建对象时必须要调用基类的构造函数，定义派生类构造函数时最好指明基类构造函数，如果不指明，就调用基类的默认构造函数（不带参数的构造函数），如果没有默认构造函数，那么编译失败。

4 基类和派生类的析构函数

和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数。

销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

5 多重继承

派生类都只有一个基类，称为**单继承**，**多继承**，即一个派生类可以有两个或多个基类。将多个基类用逗号隔开即可。

6 虚继承

为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。

7 向上/向下转型

```c++
#include <iostream>
using namespace std;
class Box{
public:
    Box(){};
    Box(int l, int w, int h) : m_length(l), m_width(w), m_height(h){
        //TODO;
    }
    
private:
    int m_length;
    int m_width;
    int m_height;
}

//声明RedBox类
class RedBox{
public:
    RedBox(int c);
    int getColor();
private:
    int m_color;
}
//Box()是基类构造函数，m_color(c)是派生类的初始化列表
RedBox::RedBox(int color) : Box(), m_color(c){
    //TODO;
}
```

