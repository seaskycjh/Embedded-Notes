## 面向对象程序设计

标签（空格分隔）： C++

[TOC]

---

### 1.OOP
面向对象程序设计的核心思想是**数据抽象**、**继承**和**动态绑定**。

数据抽象：实现类的接口与实现分离。

继承：定义相似的类型并对其相似关系建模。

动态绑定：可在一定程度上忽略相似类型的区别，以统一方式使用它们的对象。

**继承**：通过继承的类构成一种层次关系，通常层次关系的根部有一个基类（base class），其他直接或间接从基类继承而来的类称为派生类（derived class）。基类定义层次关系中所有类共有的成员，派生类定义各自特有的成员。

**动态绑定**：

### 2.定义基类和派生类

#### 2.1定义基类
基类通常都应定义一个虚析构函数。

**成员函数与继承**：派生类可以继承其基类的成员，对与类型相关的操作需提供自己的新定义以覆盖（override）旧定义。基类区分两种成员函数：

- 一是基类希望派生类进行覆盖的函数，通常将其定义为虚函数（virtual）。
- 二是基类希望派生类直接继承而不要改变的函数。任何构造函数外的非静态函数都可以是虚函数。
  

**访问控制与继承**：派生类可以可以继承定义在基类中的成员，但派生类的成员不一定有权访问从基类继承而来的成员。派生类能访问公有成员，但不能访问私有成员。

**受保护的（protected）成员**：派生类有权访问该成员，同时禁止其他用户访问。

#### 2.2定义派生类

派生类必须使用类派生列表指出它从哪个（哪些）基类继承而来。

**派生类中的虚函数**：派生类经常（但不总是）覆盖它继承的虚函数。

**派生类对象**：包含派生类自己定义的（非静态）成员的子对象和与该派生类继承的基类对应的子对象。

**派生类构造函数**：派生类不能直接初始化从基类继承而来的成员，必须使用基类的构造函数来初始化。即每个类控制它自己的成员初始化过程。

**派生类使用基类的成员**：派生类可以访问基类的公有成员和受保护成员。

**继承与静态成员**：若基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

**派生类的声明**：声明包含类名但不包含它的派生列表。

**被用作基类的类**：一个类可以是基类同时也是派生类。

```c++
/* 类派生列表的形式 */
class 派生类名：访问说明符 基类名, ... { };
/* 示例 */
class Base { ... };
class D1 : public Base { ... };
class D2 : public D1 { ... };
```
Base是D1的直接基类（direct base），同时是D2的间接基类（indirect base）。最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

#### 2.3类型转换与继承
可以将基类的指针或引用绑定到派生类对象上，其中的含义为：当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型（可能是基类的对象或派生类的对象）。

**静态类型与动态类型**：表达式的静态类型在编译时时总是已知的，它是变量声明时的类型或表达式生成的类型。。动态类型则是变量或表达时表示的内存中的对象的类型，直到运行时才可认知。若表达式既不是引用也不是指针，则它的动态类型和静态类型一致。

### 3.虚函数
当某个虚函数通过指针或引用调用一个虚函数时会执行动态绑定。所以所有虚函数都必须有定义。

**对虚函数的调用可能在运行时才被解析**：被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个。当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。

**多态性**：OOP的核心思想是多态性（polymorphism）。把具有继承关系的多个类型称为多态类型。当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有这种情况下对象的动态类型才可能与静态类型不同。

**派生类中的虚函数**：一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。当派生类覆盖了某个虚函数时，则派生类中该函数的形参和返回值必须与基类函数严格匹配。

**final和override说明符**：
若使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。
若将某个函数标记为final，则之后任何尝试覆盖该函数的操作都将引发错误。

```c++
class B {
    virtual void f1(int);
    void f2(int);
    void f3(int) final;
}
class D : B {
    void f1(int) override;  //正确，f1与基类中的f1匹配
    void f2(int) override;  //错误，基类中的f2不是虚函数
    void f3(int) override;  //错误，基类中f3已声明为final
}
```
**回避虚函数机制**：使用作用域运算符强迫执行虚函数的某个特定版本。
`int age = sp->Student::get_age();` 强行调用类Student的get_age()函数而不管sp实际指向的对象类型是什么。

### 4.抽象基类
**纯虚函数**：将函数定义为纯虚（pure virtual）函数可以清楚地告诉用户此函数没有实际意义，与普通虚函数不同，一个纯虚函数无须定义。在虚函数的声明语句后加=0就可将一个虚函数说明为纯虚函数。我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部，即不能在类的内部为一个=0的函数提供函数体。

**含有纯虚函数的类是抽象基类**：含有（或未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class）。抽象基类负责定义接口，后续的其他类可以覆盖该接口。不能（直接）创建一个抽象基类的对象。可定义抽象基类的派生类的对象，前提是派生类覆盖了纯虚函数。

**派生类构造函数只初始化它的直接基类**。

**重构（refactoring）**：负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。

### 5.访问控制与继承

5.1 访问控制

**public**：可以被任意实体访问。

**protected**：只允许子类及本类的成员函数访问。

**private**：只允许本类的成员函数访问。

每个类控制着其成员对于派生类来说是否**可访问（accessible）**。**受保护成员**：使用protected关键词来声明派生类可访问但不能被其他公共访问使用的成员。

- 和私有成员类似，受保护成员对于类的用户来说是不可访问的。
- 和公有成员类似，受保护成员对于派生类的成员和友元来说是可访问的。
- 派生类的成员或友元只能通过派生类对象来访问基类的受保护对象，对于普通基类对象中的成员不具有特殊的访问权限。例子如下：

```c++
class Base {
protected:
    int port;
};
class Sneaky : public Base {
    void clobber(Sneaky&);
    void clobber(Base&);
}
//正确，clobber能访问Sneaky对象的私有和受保护成员
void clobber(Sneaky &s) { s.port = 0; }
//错误，clobber不能访问Base对象的受保护成员
void clobber(Base &b) { b.port = 0; }
```
5.2 继承

**public继承**：不会改变基类中成员在子类中的访问权限。

**protected继承**：基类中的非私有成员（public、protected）在子类中的访问权限都变为protected。

**private继承**：基类中的非私有成员在子类中的访问权限都变为private。

无论哪种继承方式，有两点不变：

- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问。
- protected 成员可以被派生类访问。

**总结**：

1）public继承不改变基类成员的访问权限。

2）private继承使得基类所有成员在子类中的访问权限变为private。

3）protected继承将基类中public成员变为子类的protected成员，其它成员的访问权限不变。

4）基类中的private成员不受继承方式的影响，子类永远无权访问。

公有、私有和受保护继承**：

类对其继承而来的成员的访问权限受两个因素影响：

一是在基类中该成员的访问说明符，

二是在派生类的派生列表中的访问说明符。

派生访问说明符的目的是控制控制派生类（包括派生类的派生类）用户对于基类成员的访问权限。

**类的设计与受保护的成员**：考虑继承的话，可认为一个类有三种不同的用户：普通用户、类的实现者和类的继承者（派生类）。

**友元与继承**：友元关系不能继承，即基类的友元访问派生类成员或派生类的友元访问基类成员时不具有特殊性。**改变个别成员的可访问性**：通过使用using声明。

**默认继承保护级别**：使用class关键字定义的派生类时私有继承的，而使用struct关键字定义的派生类是公有继承的。

6 构造函数

6.1 继承的构造函数

派生类能够重用其直接基类定义的构造函数。

6.2 派生类的构造函数

派生类构造函数执行的次序：

1）调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左到右）

2）对派生类新增的成员对象初始化，调用顺序按照它们在类中声明的顺序

3）执行派生类的构造函数体中的内容



