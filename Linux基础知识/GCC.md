## GCC

[TOC]

------

GNU CC（简称为 gcc）是 GNU 项目中符合 ANSI C 标准的编译系统，能够编译用 C、C++和 Object C 等 语言编写的程序。 gcc 是一个交叉平台编译器，它能够在当前 CPU 平台上为多种不同体系结构的硬件平台开发软件。

### 1 gcc对文件扩展名的解释

| 扩展名      | 类型                 |
| ----------- | -------------------- |
| .c          | C语言源代码          |
| .C/.cc/.cxx | C++语言源代码        |
| .i          | 预处理后的C源代码    |
| .ii         | 预处理后的C++源代码  |
| .s/.S       | 汇编语言原始程序     |
| .h          | 预处理文件（头文件） |
| .o          | 目标文件             |
| .a/.so      | 编译后的库文件       |

### 2 gcc编译流程

#### 2.1 预处理

预处理（Pre-Processing）阶段中，gcc对包含的头文件（#include）和宏定义（#define、#ifdef 等）进行处理。

#### 2.2 编译阶段

编译（Compiling）阶段中，gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。

#### 2.3 汇编

汇编（Assembling）阶段中，gcc编译阶段生成的 .s 文件转成目标文件。

#### 2.4 链接

链接（Liking）阶段中，静态库是指将库文件的代码全部加入可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名通常为 .a 。动态库并没有将库文件的代码加入可执行文件中，而是在程序执行时加载库，这样可以节省系统的开销。一 般动态库的后缀名为 .so 。

### 3 gcc编译选项

#### 3.1 常用选项

| 选项    | 含义                                   |
| ------- | -------------------------------------- |
| -c      | 只编译不链接，生成目标文件 .o          |
| -S      | 只编译不汇编，生成汇编代码             |
| -E      | 只进行预处理，不做其他处理             |
| -g      | 在可执行文件中包含标准调试信息         |
| -o file | 将file指定为输出文件                   |
| -v      | 打印编译过程中的命令行信息和编译器版本 |
| -I dir  | 在头文件的搜索路径列表中添加dir目录    |

**-I dir**：Linux中头文件都默认放到了 /usr/include/ 目录下，当用户希望添加放置在其他位置的头文件时，就可以通过 -I dir 选项来指定，gcc就会到相应的位置查找对应的目录。

**注意**：在include语句中，< >表示在标准路径中搜索头文件，" " 表示在当前目录下搜索头文件，故不需要加上 -I选项。

#### 3.2 库选项

| 选项        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| -static     | 进行静态编译，即链接静态库，禁止使用动态库                   |
| -shared     | 可以生成动态库文件，进行动态编译，当没有动态库时链接同名静态库，默认选项 |
| -L dir      | 在库文件的搜索列表中添加 dir 目录                            |
| -lname      | 链接名为 libname.a 或 libname.so 的库文件                    |
| -fPIC/-fpic | 生成使用相对地址的位置无关的目标代码                         |

函数库有静态库和动态库两种，如果在编译某个程序时链接静态库，则链接器将会搜索静态库，从中提取出它所需要的目标文件并直接复制到该程序的可执行二进制文件(ELF 格式文件)之中；动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。

**静态库的创建和使用**：

```shell
$ gcc -c pow.c
# 使用归档工具ar将目标文件集成在一起
$ ar rcsv libpow.a pow.o
# 链接到当前目录下的静态库libpow.a
$ gcc -o test test.c -L . -lpow
```

**动态库的创建和使用**：

```shell
# 为动态库构造一个目标文件
$ gcc -fPIC -Wall -c pow.c
# 生成一个动态库libpow.so
$ gcc -shared -o libpow.so pow.o
# 链接到动态库libpow.so
$ gcc -o test test.c -L. -lpow
```

**注意**：运行使用动态库的可执行程序前，需要注册动态库的路径名，方法有：

- 修改 /etc/ld.so.conf 文件
- 修改 LD_LIBRARY_PATH 环境变量
- 将库文件直接复制到 /lib 或者 /usr/lib 目录下（这两个目录为系统的默认的库路径名）。

动态库只有当使用它的程序执行时才被链接使用，一个可以被多个程序使用的动态库称为**共享库**。

#### 3.3 警告和出错选项

| 选项      | 含义                                                     |
| --------- | -------------------------------------------------------- |
| -ansi     | 支持符合ANSI标准的C程序                                  |
| -pedantic | 允许发出ANSI C标准所列的全部警告信息                     |
| -w        | 关闭所有警告                                             |
| -Wall     | 允许发出所有警告信息                                     |
| -werror   | 把所有警告信息转化为错误信息，并在警告发生时终止编译过程 |

#### 3.4 优化选项

gcc可以对代码进行优化，它通过编译选项 -On 来控制优化代码的生成，其中n是代表优化级别的整数，一般取0~3。使用优化选项 -O 主要进行线程跳转和延迟退栈两种优化。使用优化选项 -O2 还要进行处理器指令调度等其他优化。使用优化选项 -O3 还要处理循环展开等其他与处理器特性相关的优化工作。

