## 内存管理

[TOC]

------

### 1 内存分配方式

内存分配方式有三种：

- 从静态存储区分配，在程序编译时就分配好，且这块内存在程序的整个运行期间都存在。
- 在栈上创建。由编译器分配。
- 从堆上分配，也叫动态内存分配。动态内存的生存期由程序员决定。

### 2 内存分区

在没有运行程序前，也就是说**程序没有加载到内存前**，可执行程序内部已经分好3段信息，分别为**代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分**。

运行可执行程序时，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。五部分内容（由高地址到低地址）：

**栈区**（stack）：由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。地址向下增长。

**堆区**（heap）：用于动态内存分配。地址向上增长。

**未初始化数据区**（BSS）：存放全局、静态的未初始化数据，生存周期为整个程序运行过程。

**全局初始化数据区/静态数据区**（data segment）：存放全局、静态的初始化数据，生存周期为整个程序运行过程。

**代码区**（text segment）：存放可执行文件的二进制代码，通常是只读的，运行时不可修改。

2 常见的内存错误及其对策

内存分配未成功，却使用了指针

解决方法：使用内存前先检查指针是否为NULL。若指针p是函数参数，则在函数入口处用assert(p!=NULL)进行检查，若用malloc或new来申请内存，则用`if(p==NULL)`进行防错处理。

内存分配成功，但未初始化就进行引用

无论以何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略。

内存分配成功且已初始化，但操作越过了内存的边界

避免数组或指针的下标越界。

忘记释放内存，造成内存泄漏

动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同。

释放了内存却继续使用它

4 内存操作函数

4.1 memset

将s的内存区域的前n个字节以参数c填入。

4.2 memcpy

拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。

4.3 memmove

memmove()
memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。

4.4 memcmp

比较s1和s2所指向内存区域的前n个字节。

```c
#include <string.h>
void *memset(void *s, int c, size_t n);
//返回s的首地址
void *memcpy(void *dest, const void *src, size_t n);
//返回dest的首地址
int memcmp(const void *s1, const void *s2, size_t n);
//返回值：相等：=0 大于：>0 小于：<0
```

### 5 堆区内存分配释放

#### 5.1 malloc

在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。

#### 5.2 calloc

calloc返回内存的指针之前将它初始化为0，calloc的参数包括所需元素的数量和每个元素的字节，根据这些值可以计算出总共需要分配的内存空间。

#### 5.3 realloc

realloc函数用于修改一个原先已经分配的内存块的大小，可以使一块内存的扩大或缩小。当起始空间的地址为空，即 ptr = NULL，则同malloc。当 ptr 非空：若new_size < size，即缩小 ptr 所指向的内存空间，该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依然保留；若new_size > size,即扩大 ptr 所指向的内存空间，如果原先的内存尾部有足够的扩大空间，则直接在原先的内存块尾部新增内存，如果原先的内存尾部空间不足，或原先的内存块无法改变大小，realloc将重新分配另一块new_size大小的内存，并把原先那块内存的内容复制到新的内存块上。因此，使用realloc后就应该改用realloc返回的新指针。

#### 5.4 free

释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。free只是把指针所指向的内存释放掉，并没有把指针删除掉，例如指针p被free后其地址依然不变（非NULL），只是该地址对应得内存是垃圾（无意义），p成为野指针。

```c
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nums, size_t size);
void *realloc(void *ptr, size_t new_size);
//成功返回分配空间的起始地址，失败返回NULL
void free(void *ptr);
```



