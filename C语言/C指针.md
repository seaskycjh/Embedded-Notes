C指针

[TOC]

------

1 定义

计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样。为了正确地访问这些数据，必须为每个字节都编上号码。将内存中字节的编号称为**地址**（Address）或**指针**（Pointer）。

1.1 一切皆地址

CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。

虽然变量名、函数名、字符串名和数组名在本质上都是地址的助记符，但在编写代码的过程中，认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址。

2 指针变量

在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。

2.1 定义指针变量

定义指针变量时必须带 \*，给指针变量赋值时不能带 \*。

和普通变量一样，指针变量也可以被多次写入。

2.2 通过指针变量取得数据

\* 称为指针运算符，用来取得某个地址上的数据。定义指针变量时的 \* 和使用指针变量时的 \* 意义完全不同。

程序被编译和链接后，变量 a、指针 p 被替换成相应的地址。使用 *p 的话，要先通过 p 的地址取得变量 p 的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；使用 a 的话，可以通过 a 的地址直接取得它的数据，只需要一步运算。<font color=red>使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</font>

```c
/* 定义指针变量 */
int a = 100;
int *p = &a;  //用取地址符&将a的地址赋给指针变量p
*p;  //*称为指针运算符，用来取得某个地址上的数据
*&a;  //即 *(&a)，先取a的地址，再取这个地址上的数据，等价于a
&*p;  //即 &(*p)，先取p指向的数据（a），再取数据的地址，等价于p
```

2.3 指针运算

指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。

指针变量加减运算的结果跟数据类型的长度有关。

3 二级指针

如果一个指针指向的是另外一个指针，我们就称它为**二级指针**，或者指向指针的指针。

指针变量也是一种变量，也会占用存储空间，也可以使用 & 获取它的地址。

```c
int a = 100;
int *p1 = &a;
int **p2 = &p1;
```

4 指针数组

如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。

4 数组指针

4.1 数组

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。

在C语言中，我们将第 0 个元素的地址称为数组的首地址。

**注意**：数组名的本意是表示整个数组，但在使用过程中经常会转换为指向数组第 0 个元素的指针。

4.2 一维数组指针

如果一个指针指向了数组，我们就称它为**数组指针**（Array Pointer）。

数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关。根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。

```c
int a[5] = {1,2,3,4,5};
int *p = a;  //等价于 p = &a[0]，p、a、&a[0]都指向数组第0个元素
int len = sizeof(p)/sizeof(int);  //错误，sizeof(p)得到的是指针变量本身所占内存，即4
*p++;  //等价于*(p++)，先取得p当前指向元素即a[0]的值，再将p指向下一个元素
*++p;  //等价于*(++p)，先使p指向下一个元素，再取得p指向元素的值
(*p)++;  //先取得该元素的值再对其加1
*(p+i);  //等价于a[i]、p[i]，访问数组元素
```

<font color=red>4.3 二维数组指针</font>

二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的。

C语言中的二维数组是按行排列的，每行中的个元素也依次存放。

对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关。

```c
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
int (*p)[4] = a;  //(*)表明p是一个指针，指向一个数组，数组的元素类型为int[4]
p+1;  //p 指向的数据类型是int[4]，那么p+1就前进 4×4 = 16 个字节
*(p+1);  //等价于p[i]，表示第1行的数据，使用时转换为第1行数据的首地址，即&a[0][0]
*(*(p+1)+1);  //表示第1行第1个元素的值，即a[0][1]
/* 等价关系 */
a[i][j] == p[i][j] == *(p[i]+j) == *(*(p+i)+j);
```

5 函数指针

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址。把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

```c
int max(int a, int b){
	return a>b ? a : b;
}
int main()
{
    int x = 1, y = 2;
    int (*pmax)(int, int) = max;  //把函数入口地址赋给函数指针
    printf("%d", (*pmax)(1, 2));  //通过函数指针调用函数，等价于pmax(1, 2)
}
```

6 小结

| 定义         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| int *p;      | p 可以是 int 类型指针，也可以是 int 类型数组指针             |
| int **p;     | p 为二级指针，指向 int * 类型的数据                          |
| int *p[n];   | p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]) |
| int (*p)[n]; | p 为二维数组指针                                             |
| int *p();    | p 是一个指针函数，它的返回值类型为 int *                     |
| int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数               |

7 指针易错点

6.1 使用未初始化的指针

指针未初始化时，系统会给指针分配一个随机地址。

```c
int *p = NULL;
*p = 10;
```

指针p未初始化，故将10写到了未知的内存位置，若p指向系统空间，会导致程序或系统崩溃。

6.2 没有释放内存

在堆中开辟内存后，使用完成必须释放内存，否则会造成内存泄漏。

```c
int *p = (int *)malloc(100);
free(p);
p = NULL;
```

6.3 不断修改指针变量

使用指针开辟了内存空间，然后如果对指针指向进行改变操作，操作完成后直接释放内存，会释放了不该释放的位置；另外程序丢失了对已开辟内存空间的控制，造成内存泄漏。

```c
/* 错误 */
char *p = (char *)malloc(100);
strcpy(p, "abcdefg");
p += 100;
free(p);
p = NULL;
/* 正确 */
char *tmp = p;
tmp += 100;
```

解决方法是定义两个指向同一内存空间的指针变量，一个用于操作，一个用于释放，避免造成内存泄漏。

6.4 注意野指针

**野指针**不是NULL指针，而是指向**垃圾**内存（系统随机分配的内存地址）的指针。if语句无法判断野指针。野指针的成因主要有两种：

- 声明指针变量时没有初始化。
- 指针变量被free或delete之后，没有置为NULL。
- 操作指针时超过了变量的作用范围。

```c
char *p = (char *)malloc(100);
free(p);  //错误，没有置为NULL，成为野指针
```

6.5 指针参数申请内存常见错误

若函数的形参是一个指针，则不要用该指针去申请动态内存。

```c
#include <stdlib.h>
void getMem(char *p, int num){
    p = (char *)malloc(sizeof(char) * num);
}
int main()
{
    char *ptr = NULL;
    getMem(ptr, 100);
    ...
    free(ptr);
    ptr = NULL;
    return 0;
}
```

错误，调用函数getMem会将ptr的值传递给p，但调用结束后ptr的值并未改变，是一个野指针，且每调用一次getMem函数就会泄漏一块内存。

指针参数申请内存的两种正确用法：

使用函数返回值来传递动态内存：

```c
#include <stdlib.h>
char *getMem(char *p, int num){
    p = (char *)malloc(sizeof(char) * num);
    return p;
}
int main()
{
    char *ptr = NULL;
    ptr = getMem(ptr, 100);
    ...
    return 0;
}
```

使用指向指针的指针作为参数来传递动态内存：在需要改变指针变量本身的时候，需要使用指向指针的指针作为参数，这也是传值与传地址的差别所在。

```c
#include <stdlib.h>
void getMem(char **p, int num){
    *p = (char *)malloc(sizeof(char) * num);
}
int main()
{
    char *ptr = NULL;
    getMem(&ptr, 100);
    ...
    return 0;
}
```

