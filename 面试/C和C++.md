## C/C++

[TOC]

------

### 1 C语言

### 2 C++

#### 2.1 虚函数及其作用

指向基类的指针在操作它的多态类对象时，可以根据指向的不同类对象调用其相应的函数，这个函数就是虚函数。

虚函数的作用：在基类定义了虚函数后，可以在派生类中对虚函数进行重新定义，并且可以通过基类指针或引用，在程序的运行阶段动态地选择调用基类和不同派生类中的同名函数。

<font color=red>使用虚函数时，需要注意以下几个方面的内容（重要）：</font>

- 只需要在声明函数的类体中使用关键字virtual将函数声明为虚函数，而定义函数时不需要使用关键字virtual。
- 当将基类中的某一成员函数声明为虚函数后，**派生类中的同名函数自动成为虚函数**。
- 非类的成员函数、全局函数以及类的中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。
- 基类的析构函数应该定义为虚函数，否则会造成内存泄漏。

#### 2.2 多态

多态的实现分为静态多态和动态多态。

静态多态：主要是重载，在编译时就已经确定。

动态多态：利用虚函数机制实现，在运行期间动态绑定。

#### <font color=red>2.3 重载、重写和重定义</font>

重载（overload）：

在同一个作用域内；函数名相同，参数列表不同（参数**个数不同**，或者参数**类型不同**，或者**参数个数和参数类型都不同**），返回值类型可相同也可不同；这种情况叫做c++的重载！

**c++函数重载达到的效果**：调用函数名相同的函数，会根据实参的类型和实参顺序以及实参个数选择相应的函数。c++函数重载是一种静态多态。

重写（override）：

当在子类中定义了一个与父类**完全相同**的虚函数时，则称子类的这个函数**重写（也称覆盖）**了父类的这个虚函数。

覆盖（重写）达到的效果：在子类中重写了父类的虚函数，那么子类对象调用该重写函数，调用到的是子类内部重写的虚函数，而并不是从父类继承下来的虚函数（这其实就是动态多态的实现）。

覆盖（重写）的两个必要条件：父类函数为虚函数，并且父类和子类函数的函数名、参数个数、参数类型等都必须相同。

重定义（redefine）：

重定义（隐藏）是指派生类的函数屏蔽了与其同名的基类函数，隐藏的**不光是类的成员函数**，还可以是**类的成员变量**；规则如下：

- 如果派生类的函数与基类的函数同名，但是参数不同，则不论有无virtual关键字， 基类的函数都将被隐藏。
- 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字，此时基类的函数被隐藏。

### 3 C和C++

#### 3.1 C和C++的区别

机制不同：C是面向过程的（但也可以编写面向对象的程序）；C++是面向对象的，提供了类。

适用领域不同：C适合代码体积小，效率高的场合；C++适合更上层的，复杂的。

语法：C++具有封装、继承和多态三种特性，增加了许多类型安全功能，支持泛型编程。

#### 3.2 面向对象与面向过程

**面向对象**：把数据及对数据的操作方法放在一起，作为一个相互依存的整体，即对象。对同类对象抽象出其共性，即类，类中的大多数数据，只能被本类的方法进行处理。类通过一些简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。

**面向过程**：一种以事件为中心的开发方法，就是自顶向下顺序执行，逐步求精，其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构，各模块之间的关系也比较简单，在功能上相对独立，每一模块内部一般都是由顺序、选择和循环三种基本结构组成的，

#### 3.3 C和C++的struct

- C语言的struct不能有函数成员，而C++的struct可以有。
- C语言的struct中数据成员没有private、public和protected访问权限的设定，而C++ 的struct的成员有访问权限设定。
- C语言的struct是没有继承关系的，而C++的struct却有丰富的继承关系。

C语言中的struct没有权限设置，是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。

C++中的 struct与class的区别

- 默认继承权限不同。class继承默认是private继承，而struct继承默认是public继承。
- class还用于定义模板参数，就像typename，但关键字struct不用于定义模板参数。

#### 3.4 引用和指针

- 引用只能在定义时被初始化一次，之后不能被改变，具有**从一而终**的特性。而指针却是可变的。
- 引用使用时不需要解引用（*），而指针需要解引用。
- 引用不可以为空，而指针可以为空。
- 对引用进行sizeof操作得到的是所指向的变量（对象）的大小，而对指针进行sizeof操作得到的是指针本身（所指向的变量或对象的地址）的大小。
- 作为参数传递时，两者不同。

#### 3.5 malloc/free和new/delete：

- malloc/free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它 们都可用于申请动态内存和释放内存。
- maloc/free 无法满足动态对象的要求，不能执行构造函数和析构函数。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。

#### 4 关键字

#### 4.1 static关键字

- 在函数体内，被声明为静态的变量只初始化一次，以后该函数再被调用，将不会再初始化。
- 在模块内（但在函数体外），如果把一个变量或者函数声明为静态的，那么可以将其作用域被限制在本模块内，起一个“隐藏”的作用，避免命名冲突。
- 默认初始化为0，因为静态变量存储在静态数据区，而静态数据区中的所有字节默认值都是0x00。
- 在C++中，在类中声明static变量或者函数。其初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。

#### 4.2 const关键字

- 定义常量，使其值不可被修改，且编译器可以对其进行类型检查。
- 修饰函数形参，防止其值被意外修改，提高程序健壮性。
- 修饰常量指针`const char * p`和指针常量`char * const p`。
- 修饰函数返回值。
- 在C++中，修饰类成员函数，任何不会修改数据成员的函数都应该用const修改。以及修饰类成员数据。

#### 4.3 volatile关键字

volatile是一个类型修饰符，被其修饰的变量，编译器不会对其进行优化。所以每次用到它的时候都是直接从对应的内存当中提取，而不会利用cache(缓存)或寄存器中的原有数值。一般用来修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。

