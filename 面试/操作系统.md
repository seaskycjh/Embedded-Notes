操作系统

[TOC]

------

### 1 进程

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发。

#### 1.1 孤儿进程

若父进程退出，而它的子进程还在运行，则这些子进程称为孤儿进程。孤儿进程将称为init进程的子进程，并由init进程完成它们的状态收集工作。

#### 1.2 僵尸进程

子进程退出，而父进程没有调用 wait 或 waitpid 函数获取子进程的状态信息，导致子进程的资源被释放，但保留了进程号PID、退出状态等信息，这种进程称为僵尸进程。

**避免**：

- 父进程通过wait或waitpid函数等待子进程结束（会导致父进程挂起）。
- 调用signal函数处理SIGCHLD信号。可以在信号处理函数中调用wait回收，或者直接忽略该信号。
- fork两次，之后子进程退出，则孙进程被init进程接管，由init进程回收。

### 2 线程

线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。

#### 2.1 互斥和同步

**互斥**：指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。

**同步**：指线程之间所具有的一种制约关系，用于实现对资源的有序访问，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。

#### 2.2 线程间通信

临界区：通过线程的串行化来访问公共资源。

互斥量：

- 初始化锁：pthread_mutex_init
- 加锁：pthread_mutex_lock、pthread_mutex_trylock
- 解锁：pthread_mutex_unlock
- 销毁锁：pthread_mutex_destroy

条件变量：条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。

- 初始化条件变量： pthread_cond_init
- 等待条件成立： pthread_cond_wait、pthread_cond_timewait
- 激活条件变量： pthread_cond_signal、pthread_cond_broadcast
- 清除条件变量：pthread_cond_destroy

信号量：

- 信号量初始化：sem_init
- 等待信号量：sem_wait
- 释放信号量：sem_post
- 销毁信号量：sem_destroy

#### 2.3 进程与线程的区别

- 进程是系统资源分配的最小单元。线程是CPU调度的最小单元。
- 进程在执行过程中拥有独立的内存单元。线程则共享进程的内存。（线程拥有自己的栈段，共享进程的代码段、数据段和堆段）
- 进程创建和切换的开销远大于线程。
- 进程间通信较为复杂。同一进程中的线程拥有相同的地址空间，故线程间通信较为容易。
- 进程可以有多个线程。线程只能属于一个进程，必须依赖于进程而存在。
- 进程间不会互相影响。但进程中一个线程挂掉将导致整个进程挂掉。

### 3 进程间通信

#### 3.1 无名管道PIPE

- 半双工（数据只能在一个方向上流动），具有固定的读端和写端。
- 只能用于具有亲缘关系的进程间的通信（父子进程或兄弟进程间）。
- 只存在与内存中的一种特殊的文件，可使用read/write函数进行读写。

#### 3.2 有名管道FIFO

- 可用于无亲缘的进程间的通信。
- 以特殊设备文件形式存在于文件系统中。

#### 3.3 消息队列

消息的链表，存放在内核中，由队列ID进行标记。

- 面向记录。
- 独立于发送和接收进程。
- 可实现消息的随机查询。

#### 3.4 信号量

一个计数器，用于控制多个进程对共享资源的访问。

- 用于实现进程间的互斥和同步，要传递数据需结合共享内存。
- 基于操作系统的PV操作。
- 对信号量的PV操作可以加减任何正整数。

#### 3.5 共享内存

使得多个进程可以访问同一块内存空间。

- 最快的一种IPC方式。
- 需要依靠某种同步操作，如互斥锁和信号量等。

#### 3.6 套接字

可用于不同主机间的进程通信。

### 4 内存

#### 4.1 程序的内存结构

栈区：存放函数参数、局部变量等，由系统自动分配和释放，地址由高到低增长，是一块连续的内存区域。

堆区：用于动态分配内存，由程序员申请分配和释放， 从低地址位向高地址位增长，采用链式存储结构。

BSS段：存放未初始化的全局变量和静态变量，属于静态分配，程序结束后静态变量由系统自动释放。

数据段：存放程序中已初始化的全局变量，属于静态分配。

代码段：存放程序执行代码和常量，其大小在程序运行前就已确定，属于只读区域。 

#### 4.2 栈和堆的区别

- 栈内存由系统自动分配和释放，存放函数参数和局部变量。堆内存由程序员手动申请和释放。
- 栈是先进后出的，不会产生内存碎片。堆需调用malloc/free，会产生内存碎片。
- 栈由高地址向低地址生长。堆由低地址向高地址生长。
- 栈的分配效率高。堆的分配效率低。

#### 4.3 内存溢出和内存泄漏

内存溢出：程序申请内存时，没有足够的内存供申请者使用。

内存泄漏：由于疏忽或错误造成程序未能释放掉不再使用的内存的情况。

- 堆内存泄漏。
- 系统资源泄漏。
- 没有将基类的析构函数定义为虚函数。

### 5 文件I/O

#### 5.1 select函数的作用

select函数是处理I/O复用的高效方法。利用select可以同时监听多个文件描述符的读写状态，当文件描述符状态改变时，内核会通知用户已准备好的文件描述符的数量、已准备好的条件等。通过使用 select 和 poll 函数的返回结果，就可以调用相应的 I/O 处理函数。

#### 5.2 死锁

如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件那么该进程集合就是死锁的。

**条件**：互斥条件、占有和等待条件、不可抢占条件、环路等待条件。

**如何避免**：系统对进程发出的每一个资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后可能发送死锁，则不分配，否则分配。

### 6 程序编译

#### 6.1 编译过程

**预编译**：处理预编译指令，包括宏定义、条件编译、文件包含。

**编译**：将预编译得到的 .i 文件经过处理后生成相应的汇编文件。

**汇编**：将汇编代码转变成机器码，即目标文件。

**链接**：将不同源文件产生的目标文件进行链接，生成一个可执行程序。

#### 6.2 预编译

**typedef和#define**：

#### 6.3 静态链接和动态链接

静态链接：由多个目标文件进行链接形成的是静态库。缺点：浪费空间，程序所需要的目标文件都要有一个副本。更新困难，当库函数的代码改变时就需要重新进行编译链接形成可执行文件。优点：运行速度快。

动态链接：把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序。因此既节约了空间，更新也方便，运行速度会变慢一点。

### 7 用户态和内核态

#### 7.1 用户态和内核态的区别

用户态和内核态是操作系统的两种运行级别，用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统的内核数据结构和程序。

#### 7.1 用户态切换到内核态

系统调用：用户主动切换到内核态的一种方式，其实质还是使用了操作系统为用户特别开放的中断。

异常：在用户态发生某些不可知异常时，会切换到处理异常的相关程序中，即内核中。

外围设备中断：外围设备完成用户请求的操作后会向CPU发出相应中断信号，CPU转到中断处理程序。