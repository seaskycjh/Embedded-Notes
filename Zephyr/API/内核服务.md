## Zephyr内核服务

[TOC]



### 1 调度，中断和同步

#### 1.1 线程

线程（Thread）是一个内核对象，用于处理较长和较复杂的程序。一个线程有以下关键属性：

- 堆栈区域：一个用于线程堆栈的内存区域。
- 线程控制块：用于记录线程的元数据，类型为 `struct k_thread`。
- 入口点函数：启动线程时调用的函数，最高可以传递三个参数给此函数。
- 调度优先级：指示内核调度程序如何分配线程的CPU执行时间。
- 线程选项：运行线程再特定情况下接受特殊处理。
- 启动延时：指定开始线程前应该等待多久。
- 执行模式：可以是超级用户或用户模式。默认为管理者模式，允许访问特权的CPU指令，整个内存地址空间和外围设备。

1.1.1 生命周期

**线程创建**：

线程终止：

线程中止：

线程挂起：

1.1.2 线程状态

1.1.3 线程优先级

1.1.4 线程选项

#### 1.2 调度

#### 1.3 系统线程

#### 1.4 工作队列

工作队列（Workqueue）是一个内核对象，使用一个专用线程以先进先出的方式来处理工作项。每个工作项指定自己的工作函数。工作队列通常使用 ISR 或 高优先级线程来实现，因此不会影响对时间敏感的处理。

工作队列有以下关键属性：

- 添加了工作项的**队列**（工作项但还未处理）。
- 用来处理队列中工作项的**线程**（此线程的优先级是可配置的）。

一个工作队列在使用前必须先初始化（将队列清空并创建工作队列的线程）。

1.4.1 工作项生命周期

可以定义任意数量的工作项（Work Item），工作项有以下关键属性：

- 处理函数（handler function）：处理工作项时线程所执行的函数。
- 等待标志（pending flag）：内核以此来表示此工作项是工作队列的一员。
- 队列链接（queue link）：内核以此来链接到下一个工作项。

工作项在使用前必须初始化（记录工作项的处理函数并将它标记为非等待）。

1.4.2 延迟工作

若要在指定一段时间后处理工作项，可以提交一个延迟的工作项到工作队列。一个延迟的工作项是一个添加了以下属性的标准的工作项：

- 延迟时间（delay）：提交前等待的时间间隔。
- 工作队列指标（workqueue indicator）：指定要被提交到队列的工作项。

1.4.3 触发工作

1.4.4 系统工作队列

#### 1.5 中断

中断服务程序（ISR）是一个异步执行硬件或软件中断响应的函数。

##### 1.5.1 概念

可以定义任意数量的 ISR，但实际上受底层硬件的限制。一个 ISR 有以下关键属性：

- 中断请求（interrupt request，IRQ）：触发 ISR。
- 优先级（priority level）：与中断请求优先级有关。
- 中断处理函数（interrupt handler function）：被调用来处理中断。
- 参数（argument value）：被传递给函数。

中断描述表用于关联中断源到 ISR，一个 ISR 只能被关联到一个 IRQ。多个 ISR 可以使用同一个中断处理函数，ISR 可以通过参数告知函数具体是哪个中断。

##### 1.5.2 多级中断

硬件平台通过使用一个或多个嵌套中断控制器来支持更多的中断。分配一个唯一的 32 位中断数字来选择并调用正确的 ISR。每个字节代表一级中断，所以共有 4 级中断。

1.5.3 防止中断

1.5.4 零延迟中断

1.5.5 卸载中断

#### 1.6 轮询

轮询 APIs 的主要函数是 k_poll()，它在概念上与 POSIX 的 poll() 函数非常相似，只是它操作的是内核对象而不是文件描述符。

轮询 API 允许单个线程并发地等待一个或多个条件被满足，而无需主动地逐个查看每个条件。

这种条件是有限制的：

- 一个信号量变得可用。
- 内核 FIFO 包含准备检索的数据。
- 一个 poll 信号被发出。

希望等待多个条件的线程必须定义一个轮询事件数组，每个条件一个。

#### 1.7 信号量

信号量（semaphore）是实现传统计数信号量的内核对象。

**概念**

一个信号量有以下关键属性：

- 计数（count）指示信号量能被获取（be taken）的次数，计数为 0 表示信号量不可用。
- 极限（limit）指示信号量可以达到的最大值。

信号量在使用前必须先初始化，它的计数值必须被设置为小于或等于其极限值的非负值。

信号量可以由线程或 ISR 释放（give），这会使信号量计数增加，除非计数已经等于极限。

信号量可以被线程获取（take），这会使信号量的计数减少，除非计数等于0。当一个信号量不可用时，线程可以等待它被给出。任何数量的线程都可以同时等待一个不可用的信号量，当信号量被给出时，会被等待时间最长且优先级最高的线程获取。

**实现**

```c
/* 定义一个信号量 */
struct k_sem my_sem;
k_sem_init(&my_sem, 0, 1);	//count = 0, limit = 1
//或者使用
K_SEM_DEFINE(my_sem, 0, 1);
/* 释放一个信号量 */
k_sem_give(&my_sem);
/* 获取一个信号量 */
k_sem_take(&my_sem, K_MSEC(50));  //等待 50ms 来获取信号量
```

**建议用法**

- 使用信号量控制多个线程对共有资源的访问。
- 使用信号量在线程或 ISR 的生产者和消费者之间间的同步处理。

#### 1.8 互斥锁

互斥锁（mutex）是实现传统可重入互斥锁的内核对象。互斥锁通过保证资源的排他性访问来允许多个线程安全地共享相关的硬件或软件资源。

**概念**

一个互斥锁有以下关键属性：

- 锁计数（lock count）指示互斥锁被线程锁住的次数。为 0 表示互斥锁已解锁。
- 拥有线程（owning thread）在锁住互斥锁时标识加锁的线程。

互斥锁在使用前必须先初始化，这会将锁计数设置为 0。

需要使用共享资源的线程必须先锁定关联的互斥锁来获得访问资源的独占权限。如果互斥锁已被另一个线程锁定，则发出请求的线程可以选择等待互斥锁被解锁。

锁定互斥锁之后，线程可以安全地使用相关资源。但是，最后尽可能短地持有锁。当线程不再需要该资源时，必须解锁互斥锁，其他线程才能使用该资源。

任何数量的线程都可以同时等待一个锁定的互斥锁。当互斥锁被解锁时，等待时间最长且优先级最高的线程就会锁定它。

**可重入锁**

允许线程锁定它已经锁定的互斥锁，这使得线程可以在执行时访问相关的资源，因为此时互斥锁可能已经被锁定，也可能未被锁定。

一个互斥锁被一个线程反复锁住，则此互斥锁必须被解锁相同的次数，这样它才能被其他线程使用。

### 2 数据传递

下表列出可用于线程和中断服务程序之间传递数据的内核对象。

| 对象        | 双向 | 数据结构 | 数据项大小 | 数据对齐 | ISR接收 | ISR发送 |
| ----------- | ---- | -------- | ---------- | -------- | ------- | ------- |
| FIFO        | 否   | 队列     | 任意       | 4 B      | 是      | 是      |
| LIFO        | 否   | 队列     | 任意       | 4 B      | 是      | 是      |
| Stack       | 否   | 数组     | 字         | 字       | 是      | 是      |
| Messa queue | 否   | 环形缓冲 | 2次方      | 2次方    | 是      | 是      |
| Mailbox     | 是   | 队列     | 任意       | 任意     | 否      | 否      |
| Pipe        | 否   | 环形缓冲 | 任意       | 任意     | 否      | 否      |

#### 2.1 FIFO

FIFO 是一个内核对象，实现了传统的先进先出队列，允许线程和 ISR 添加/删除任意大小的数据项。

```c
/* @brief 初始化一个 FIFO 队列
 * @param FIFO队列的地址
 */
k_fifo_init(&my_fifo);

/* @brief 写FIFO，即将一个数据项添加到FIFO中
 * @param FIFO队列的地址
 * @param 数据项的地址
 */
k_fifo_put(fifo, data);

/* @brief 读FIFO，即将一个数据项从FIFO中取出
 * @param FIFO队列的地址
 * @param 获取一个数据项的等待时间，可以是 K_NO_WAIT、K_FOREVER 或一个值
 * @return 成功返回数据项地址，失败返回NULL
 */
k_fifo_get(fifo, timeout);

/* @brief 查询一个队列中是否有数据
 * @param FIFO队列的地址
 * @param 获取一个数据项的等待时间，可以是 K_NO_WAIT、K_FOREVER 或一个值
 * @return 如果有数据可以返回 0，否则返回非 0 值
 */
k_fifo_is_empty(fifo);
```

#### 2.2 LIFO

LIFO 是一个内核对象，实现了传统的后进先出队列，允许线程和 ISR 添加/删除任意大小的数据项。

#### 2.3 Stack

Stack 是一个内核对象，实现了传统的后进先出队列，允许线程和 ISR 添加/删除有限数量的整型数据。

```c
/* 入栈 */
int k_stack_push(struct k_stack *stack, stack_data_t data);

/* 出栈 */
int k_stack_pop(struct k_stack *stack, stack_data_t *data, s32_t timeout)
```

#### 2.4 消息队列

消息队列是一个内核对象，实现了一个简单的消息队列，允许线程和 ISR 异步发送和接收固定大小的数据项。

#### 2.5 消息邮箱

消息邮箱是一个内核对象，实现了一个增强版的消息队列，允许线程和 ISR 同步或异步发送/接收任意大小的消息。

#### 2.6 管道

### 3 内存管理

#### 3.1 内存堆

Zephyr 提供了一个函数集合，允许线程动态分配内存。

3.1.1 同步堆分配器

创建堆内存

定义堆最简单的方法是使用宏 `K_HEAP_DEFINE`，这将创建一个静态 `struct k_heap` 变量，该变量管理指定大小的内存区域。

也可以使用 `k_heap_init()` 来创建堆。

内存分配

使用 `k_heap_alloc()` 从堆中分配内存，类似标准C中的 malloc() 。堆支持阻塞操作，允许线程进入休眠状态，直到内存可用。

内存释放

必须使用 `k_heap_free()` 释放由 `k_heap_alloc()` 分配的内存。

3.1.2 系统堆

系统堆是一个预定义的内存分配器，允许线程从公共内存区动态分配内存。

只能定义一个系统堆，与其他堆或内存池不同，系统堆不能通过使用其内存地址来直接引用。

根据空间的可用性，系统堆可以配置为任意大小。

线程可通过调用 `k_malloc()` 动态分配一块堆内存，保证分配的地址是 4 字节对齐的，若找不到合适的内存块则返回 NULL。当线程用完一块堆内存后，可以通过调用 `k_free()` 将这块堆内存释放。

#### 3.2 内存片

内存片是一个内核对象，允许从指定内存区域分配内存块，内存片中的所有内存块都有一个固定的大小，避免了内存碎片问题。

一个内存板有以下关键属性：

- 块大小（block size）：每个内存块的块大小，以字节为单位，至少 4N 字节长，其中 N 大于 0。
- 块数量（number of blocks）：必须大于 0。
- 缓冲区（buffer）：大小为 块大小 * 块数量。

内存板使用前必须先初始化，这将所有块标记为未使用状态。

#### 3.3 内存池

内存池是一个内核对象，允许动态分配的内存块从一个指定的内存区域。

基本概念：

一个内存池具有以下关键属性：

最小块大小（minimum block size）：单位为字节，至少为 4 字节。

最大块大小（maximum block size）：单位为字节，大小为 最小块大小 * 4 ^Y^，Y >= 0。

最大块数量（number of maximum-size blocks）：必须大于0。

缓冲（buffer）：长度至少为 最大块大小 * 最大块数量

实现：

```c
//定义一个内存池
K_MEM_POOL_DEFINE(my_pool, 64, 4096, 3, 4);
```

### 4 时间

#### 4.1 内核时钟

#### 4.2 定时器

定时器是一个内核对象，当定时器到达指定时间时可以执行一个应用程序或者简单地进行记录，等待应用程序读取其状态。

```c
void k_timer_init(struct k_timer *timer, k_timer_expiry_texpiry_fn, k_timer_stop_tstop_fn);
void k_timer_start(struct k_timer *timer, s32_t duration, s32_t period);
void k_timer_stop(struct k_timer *timer);
```

### 5 其他

#### 5.1 CPU 空闲

#### 5.2 原子服务

原子变量（atomic variable）是一个 32 位的变量，可以被线程或中断以不间断的方式读取和修改。

使用内核的原子操作可以确保所需的操作正确发生，内核还支持对原子变量中的单个位进行原子操作。

```c
/* @brief 该宏用于初始化原子变量
 * @param 分配给原子变量的值 */
ATOMIC_INIT(i)

/* @brief 声明原子变量数组
 * @param 原子变量数组名
 * @param 所需比特数 */
ATOMIC_DEFINE(name, num_bits)

/* @brief 原子比较和设置，若目标当前值等于 old_value，则将目标设置为 new_value
 * @param 原子变量地址
 * @param 要比较的原始值
 * @param 要设置的新值 
 * @return 若写入了新值则为真，否则为假 */
bool atomic_cas(atomic_t *target, atomic_val_t old_value, atomic_val_t new_value);

/* @brief 原子加法
 * @param 原子变量地址
 * @param 要加的值
 * @return 目标的先前值 */
atomic_val_t atomic_add(atomic_t *target, atomic_val_t value);

/* @brief 原子减法
 * @param 原子变量地址
 * @param 要减的值 */
atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value);

/* 原子加 1 */
atomic_val_t atomic_inc(atomic_t *target);
/* 原子减 1 */
atomic_val_t atomic_dec(atomic_t *target);

atomic_val_t atomic_get(const atomict_t *target);
```

